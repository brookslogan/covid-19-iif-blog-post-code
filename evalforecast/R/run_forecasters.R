## Global used in `run_forecasters()`

.prediction_cards  <- list()

#' Return the prediction cards for forecasters that have been run
#' @return a named list of prediction cards such as those generated by [get_prediction_card()]
#' @export
get_predictions  <- function() {
    .prediction_cards
}


#' Run forecasters in specified list and populate a global variable with prediction_cards incrementally
#'
#' @param forecasters a named list of forecasters, such as those returned by [get_forecaster()]
#' @param response the response (e.g. "usafacts_deaths_incidence_num")
#' @param incidence_period the incidence period (e.g. "epiweek" for
#'     now, for all forecasters)
#' @param ahead the ahead parameter (e.g. 1, 2, 3, 4)
#' @param forecast_date the date of the forecast
#' @param geo_type the geographic type (e.g "county" or "state" or
#'     "hrr" or "msa"... but for now only the first two),
#' @param n_locations the number of locations (for now we will use 200
#'     for this)
#' @param data_list a named list of data frames for each response/geo_type, i.e. for county/state
#' @importFrom dplyr pull
#' @importFrom assertthat assert_that
#' @importFrom utils assignInMyNamespace
#' @importFrom logger log_info
#' @export
run_forecasters <- function(forecasters,
                            response,
                            incidence_period = c("epiweek"),
                            ahead,
                            forecast_date,
                            geo_type = c("county", "state", "hrr", "msa"),
                            n_locations = 200,
                            data_list) {
    ## Possible parameter combinations
    ##responses <-  list(county = "usafacts_deaths_incidence_num", state = "jhu-csse_deaths_incidence_num")
    #geo_types  <- names(responses)
    ## Plus forecast_date, making six in all
    ## End of parameter combinations

    incidence_period <- match.arg(incidence_period)
    ## Currently we only work with "county" or "state" level forecasts
    geo_type <- match.arg(geo_type)
    assert_that(geo_type %in% c("county", "state"),
                msg = 'We only use geo_type = "county"/"state" for now!')

    ## assert_that((geo_type == "county" && response == responses$county) ||
    ##             (geo_type == "state" && response == responses$state),
    ##             msg = 'Mismatched geo_type and response!')

    ## Get the appropriate data frame
    df  <- data_list[[geo_type]]

    forecaster_names  <- names(forecasters)
    assert_that(!is.null(forecaster_names))

    ## Various checks that Jacob has in the evaluator functions really
    ## belong here, but we don't muck around too much for now. For now
    ## this means we waste computing cycles...

    logger::log_info("evalforecast::run_forecasters: Choosing locations for forecasting")
    ## choose locations that we will be forecasting today:
    date_for_selection <- min(
        get_target_period(forecast_date, incidence_period, ahead) %>%
        dplyr::pull(start) - 1,
        min(forecast_date) - 1
    )

    logger::log_info(sprintf("evalforecast::run_forecasters: Getting top n_locations for %s", geo_type))
    forecast_locations <- get_top_n_locations(df = df,
                                              response = response,
                                              latest_date = date_for_selection,
                                              n = n_locations)
    ## We incrementally update a global variable because meta-forecasters like
    ## the stackedLasso use outputs of other forecasters
    ## See https://delphi-org.slack.com/archives/D0165UNP75G/p1593288682003600

    logger::log_info("evalforecast::run_forecasters: resetting global prediction list")
    result  <- vector(length = length(forecaster_names), mode = "list")
    names(result)  <- forecaster_names
    ## We must fail gracefully, so as not to stop other forecasters from running

    ## A string capturing parameter values
    param_tuple <- sprintf("response = %s, incidence_period = %s, ahead = %s, forecast_date = %s, geo_type = %s, n_locations = %d",
                           response, incidence_period, ahead, forecast_date, geo_type, n_locations)

    for (fn in forecaster_names) {
        forecaster  <- forecasters[[fn]]
        if (is.function(forecaster)) {
            logger::log_info(sprintf("Computing %s predictions for %s", fn, geo_type))
            predictions_card <- tryCatch(
                get_predictions_card(df,
                                     forecasters[[fn]],
                                     forecast_date = forecast_date,
                                     forecast_locations = forecast_locations,
                                     response = response,
                                     incidence_period = incidence_period,
                                     ahead = ahead,
                                     geo_type = geo_type,
                                     n_locations = n_locations),
                error = function(e) {
                    result  <- NA
                    attr(result, "NA_REASON") <- e$message
                    result
                }
            )
            if (!is.data.frame(predictions_card)) {
                ## The forecaster failed at run time
                logger::log_warn(sprintf("Prediction failed for forecaster %s for params: %s", fn, param_tuple))
            } else {
                logger::log_info("evalforecast::run_forecasters: Computing predictions... done!")
            }
        } else {
            ## The forecaster was not implemented
            logger::log_info(sprintf("Skipping %s as it is unimplemented for %s!",
                                     fn, param_tuple))
            predictions_card <- NA
            attr(predictions_card, "NA_REASON")  <-  "Unimplemented"
        }
        result[[fn]]  <- predictions_card
        ## For Noah
        utils::assignInMyNamespace(".prediction_cards", result)
    }
    return(result)
}
